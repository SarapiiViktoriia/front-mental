import flat from 'array.prototype.flat';
import isEqual from 'lodash.isequal';
import cheerio from 'cheerio';
import {
  nodeEqual,
  nodeMatches,
  containsChildrenSubArray,
  withSetStateAllowed,
  typeOfNode,
  isReactElementAlike,
  displayNameOfNode,
  isCustomComponentElement,
  ITERATOR_SYMBOL,
  makeOptions,
  sym,
  privateSet,
  cloneElement,
  spyMethod,
} from './Utils';
import getAdapter from './getAdapter';
import { debugNodes } from './Debug';
import {
  propsOfNode,
  getTextFromNode,
  hasClassName,
  childrenOfNode,
  parentsOfNode,
  treeFilter,
} from './RSTTraversal';
import { buildPredicate, reduceTreesBySelector } from './selectors';
const NODE = sym('__node__');
const NODES = sym('__nodes__');
const RENDERER = sym('__renderer__');
const UNRENDERED = sym('__unrendered__');
const ROOT = sym('__root__');
const OPTIONS = sym('__options__');
const SET_STATE = sym('__setState__');
const ROOT_NODES = sym('__rootNodes__');
function findWhereUnwrapped(wrapper, predicate, filter = treeFilter) {
  return wrapper.flatMap(n => filter(n.getNodeInternal(), predicate));
}
function filterWhereUnwrapped(wrapper, predicate) {
  return wrapper.wrap(wrapper.getNodesInternal().filter(predicate).filter(Boolean));
}
function validateOptions(options) {
  const {
    lifecycleExperimental,
    disableLifecycleMethods,
    enableComponentDidUpdateOnSetState,
    supportPrevContextArgumentOfComponentDidUpdate,
    lifecycles,
  } = options;
  if (typeof lifecycleExperimental !== 'undefined' && typeof lifecycleExperimental !== 'boolean') {
    throw new Error('lifecycleExperimental must be either true or false if provided');
  }
  if (typeof disableLifecycleMethods !== 'undefined' && typeof disableLifecycleMethods !== 'boolean') {
    throw new Error('disableLifecycleMethods must be either true or false if provided');
  }
  if (
    lifecycleExperimental != null
    && disableLifecycleMethods != null
    && lifecycleExperimental === disableLifecycleMethods
  ) {
    throw new Error('lifecycleExperimental and disableLifecycleMethods cannot be set to the same value');
  }
  if (
    typeof enableComponentDidUpdateOnSetState !== 'undefined'
    && lifecycles.componentDidUpdate
    && lifecycles.componentDidUpdate.onSetState !== enableComponentDidUpdateOnSetState
  ) {
    throw new TypeError('the legacy enableComponentDidUpdateOnSetState option should be matched by `lifecycles: { componentDidUpdate: { onSetState: true } }`, for compatibility');
  }
  if (
    typeof supportPrevContextArgumentOfComponentDidUpdate !== 'undefined'
    && lifecycles.componentDidUpdate
    && lifecycles.componentDidUpdate.prevContext !== supportPrevContextArgumentOfComponentDidUpdate
  ) {
    throw new TypeError('the legacy supportPrevContextArgumentOfComponentDidUpdate option should be matched by `lifecycles: { componentDidUpdate: { prevContext: true } }`, for compatibility');
  }
}
function getAdapterLifecycles({ options }) {
  const {
    lifecycles = {},
    enableComponentDidUpdateOnSetState,
    supportPrevContextArgumentOfComponentDidUpdate,
  } = options;
  const hasLegacySetStateArg = typeof enableComponentDidUpdateOnSetState !== 'undefined';
  const hasLegacyPrevContextArg = typeof supportPrevContextArgumentOfComponentDidUpdate !== 'undefined';
  const componentDidUpdate = hasLegacySetStateArg || hasLegacyPrevContextArg
    ? {
      ...(hasLegacySetStateArg && {
        onSetState: !!enableComponentDidUpdateOnSetState,
      }),
      ...(hasLegacyPrevContextArg && {
        prevContext: !!supportPrevContextArgumentOfComponentDidUpdate,
      }),
    }
    : null;
  return {
    ...lifecycles,
    setState: {
      ...lifecycles.setState,
    },
    ...(componentDidUpdate && { componentDidUpdate }),
  };
}
function getRootNode(node) {
  if (node.nodeType === 'host') {
    return node;
  }
  return node.rendered;
}
function getRootNodeInternal(wrapper) {
  if (wrapper[ROOT].length !== 1) {
    throw new Error('getRootNodeInternal(wrapper) can only be called when wrapper wraps one node');
  }
  if (wrapper[ROOT] !== wrapper) {
    return wrapper[ROOT_NODES][0];
  }
  return wrapper[ROOT][NODE];
}
function nodeParents(wrapper, node) {
  return parentsOfNode(node, getRootNodeInternal(wrapper));
}
function privateSetNodes(wrapper, nodes) {
  if (!Array.isArray(nodes)) {
    privateSet(wrapper, NODE, nodes);
    privateSet(wrapper, NODES, [nodes]);
  } else {
    privateSet(wrapper, NODE, nodes[0]);
    privateSet(wrapper, NODES, nodes);
  }
  privateSet(wrapper, 'length', wrapper[NODES].length);
}
function pureComponentShouldComponentUpdate(prevProps, props, prevState, state) {
  return !isEqual(prevProps, props) || !isEqual(prevState, state);
}
function isPureComponent(instance) {
  return instance && instance.isPureReactComponent;
}
class ShallowWrapper {
  constructor(nodes, root, passedOptions = {}) {
    validateOptions(passedOptions);
    const options = makeOptions(passedOptions);
    const adapter = getAdapter(options);
    const lifecycles = getAdapterLifecycles(adapter);
    if (!root) {
      if (!adapter.isValidElement(nodes)) {
        throw new TypeError('ShallowWrapper can only wrap valid elements');
      }
      privateSet(this, ROOT, this);
      privateSet(this, UNRENDERED, nodes);
      const renderer = adapter.createRenderer({ mode: 'shallow', ...options });
      privateSet(this, RENDERER, renderer);
      this[RENDERER].render(nodes, options.context);
      const renderedNode = this[RENDERER].getNode();
      privateSetNodes(this, getRootNode(renderedNode));
      privateSet(this, OPTIONS, options);
      const { instance } = renderedNode;
      if (instance && !options.disableLifecycleMethods) {
        if (lifecycles.componentDidUpdate.onSetState && !instance[SET_STATE]) {
          privateSet(instance, SET_STATE, instance.setState);
          instance.setState = (updater, callback = undefined) => this.setState(
            ...(callback == null ? [updater] : [updater, callback]),
          );
        }
        if (typeof instance.componentDidMount === 'function') {
          this[RENDERER].batchedUpdates(() => {
            instance.componentDidMount();
          });
        }
      }
    } else {
      privateSet(this, ROOT, root);
      privateSet(this, UNRENDERED, null);
      privateSet(this, RENDERER, root[RENDERER]);
      privateSetNodes(this, nodes);
      privateSet(this, OPTIONS, root[OPTIONS]);
      privateSet(this, ROOT_NODES, root[NODES]);
    }
  }
  root() {
    return this[ROOT];
  }
  getNodeInternal() {
    if (this.length !== 1) {
      throw new Error('ShallowWrapper::getNode() can only be called when wrapping one node');
    }
    if (this[ROOT] === this) {
      this.update();
    }
    return this[NODE];
  }
  getNodesInternal() {
    if (this[ROOT] === this && this.length === 1) {
      this.update();
    }
    return this[NODES];
  }
  getElement() {
    return this.single('getElement', n => getAdapter(this[OPTIONS]).nodeToElement(n));
  }
  getElements() {
    return this.getNodesInternal().map(getAdapter(this[OPTIONS]).nodeToElement);
  }
  getNode() {
    throw new Error('ShallowWrapper::getNode() is no longer supported. Use ShallowWrapper::getElement() instead');
  }
  getNodes() {
    throw new Error('ShallowWrapper::getNodes() is no longer supported. Use ShallowWrapper::getElements() instead');
  }
  instance() {
    if (this[ROOT] !== this) {
      throw new Error('ShallowWrapper::instance() can only be called on the root');
    }
    return this[RENDERER].getNode().instance;
  }
  update() {
    if (this[ROOT] !== this) {
      throw new Error('ShallowWrapper::update() can only be called on the root');
    }
    if (this.length !== 1) {
      throw new Error('ShallowWrapper::update() can only be called when wrapping one node');
    }
    privateSetNodes(this, getRootNode(this[RENDERER].getNode()));
    return this;
  }
  unmount() {
    this[RENDERER].unmount();
    return this;
  }
  rerender(props, context) {
    const adapter = getAdapter(this[OPTIONS]);
    this.single('rerender', () => {
      withSetStateAllowed(() => {
        const instance = this.instance() || {};
        const { state } = instance;
        const prevProps = instance.props || this[UNRENDERED].props;
        const prevContext = instance.context || this[OPTIONS].context;
        const nextContext = context || prevContext;
        if (context) {
          this[OPTIONS] = { ...this[OPTIONS], context: nextContext };
        }
        this[RENDERER].batchedUpdates(() => {
          let shouldRender = true;
          let spy;
          if (
            !this[OPTIONS].disableLifecycleMethods
            && instance
            && typeof instance.shouldComponentUpdate === 'function'
          ) {
            spy = spyMethod(instance, 'shouldComponentUpdate');
          } else if (isPureComponent(instance)) {
            shouldRender = pureComponentShouldComponentUpdate(
              prevProps,
              props,
              state,
              instance.state,
            );
          }
          if (props) this[UNRENDERED] = cloneElement(adapter, this[UNRENDERED], props);
          this[RENDERER].render(this[UNRENDERED], nextContext);
          if (spy) {
            shouldRender = spy.getLastReturnValue();
            spy.restore();
          }
          if (
            shouldRender
            && !this[OPTIONS].disableLifecycleMethods
            && instance
          ) {
            const lifecycles = getAdapterLifecycles(adapter);
            if (lifecycles.getSnapshotBeforeUpdate) {
              let snapshot;
              if (typeof instance.getSnapshotBeforeUpdate === 'function') {
                snapshot = instance.getSnapshotBeforeUpdate(prevProps, state);
              }
              if (
                lifecycles.componentDidUpdate
                && typeof instance.componentDidUpdate === 'function'
              ) {
                instance.componentDidUpdate(prevProps, state, snapshot);
              }
            } else if (
              lifecycles.componentDidUpdate
              && typeof instance.componentDidUpdate === 'function'
            ) {
              if (lifecycles.componentDidUpdate.prevContext) {
                instance.componentDidUpdate(prevProps, state, prevContext);
              } else {
                instance.componentDidUpdate(prevProps, state);
              }
            }
          } else if (!isEqual(props, instance.props)) {
            instance.props = (Object.freeze || Object)({ ...instance.props, ...props });
          }
          this.update();
        });
      });
    });
    return this;
  }
  setProps(props, callback = undefined) {
    if (this[ROOT] !== this) {
      throw new Error('ShallowWrapper::setProps() can only be called on the root');
    }
    if (arguments.length > 1 && typeof callback !== 'function') {
      throw new TypeError('ReactWrapper::setProps() expects a function as its second argument');
    }
    this.rerender(props);
    if (callback) {
      callback();
    }
    return this;
  }
  setState(state, callback = undefined) {
    if (this[ROOT] !== this) {
      throw new Error('ShallowWrapper::setState() can only be called on the root');
    }
    if (this.instance() === null || this[RENDERER].getNode().nodeType !== 'class') {
      throw new Error('ShallowWrapper::setState() can only be called on class components');
    }
    if (arguments.length > 1 && typeof callback !== 'function') {
      throw new TypeError('ReactWrapper::setState() expects a function as its second argument');
    }
    this.single('setState', () => {
      withSetStateAllowed(() => {
        const adapter = getAdapter(this[OPTIONS]);
        const lifecycles = getAdapterLifecycles(adapter);
        const instance = this.instance();
        const prevProps = instance.props;
        const prevState = instance.state;
        const prevContext = instance.context;
        const statePayload = typeof state === 'function'
          ? state.call(instance, prevState, prevProps)
          : state;
        const maybeHasUpdate = !lifecycles.setState.skipsComponentDidUpdateOnNullish
          || statePayload != null;
        let spy;
        let shouldRender = true;
        if (
          !this[OPTIONS].disableLifecycleMethods
          && lifecycles.componentDidUpdate
          && lifecycles.componentDidUpdate.onSetState
          && instance
          && typeof instance.shouldComponentUpdate === 'function'
        ) {
          spy = spyMethod(instance, 'shouldComponentUpdate');
        } else if (isPureComponent(instance)) {
          shouldRender = pureComponentShouldComponentUpdate(
            prevProps,
            instance.props,
            prevState,
            statePayload,
          );
        }
        if (instance[SET_STATE]) {
          instance[SET_STATE](statePayload);
        } else {
          instance.setState(statePayload);
        }
        if (spy) {
          shouldRender = spy.getLastReturnValue();
          spy.restore();
        }
        if (
          maybeHasUpdate
          && shouldRender
          && !this[OPTIONS].disableLifecycleMethods
          && lifecycles.componentDidUpdate
          && lifecycles.componentDidUpdate.onSetState
          && instance
        ) {
          if (
            lifecycles.getSnapshotBeforeUpdate
            && typeof instance.getSnapshotBeforeUpdate === 'function'
          ) {
            const snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);
            if (typeof instance.componentDidUpdate === 'function') {
              instance.componentDidUpdate(prevProps, prevState, snapshot);
            }
          } else if (typeof instance.componentDidUpdate === 'function') {
            if (lifecycles.componentDidUpdate.prevContext) {
              instance.componentDidUpdate(prevProps, prevState, prevContext);
            } else {
              instance.componentDidUpdate(prevProps, prevState);
            }
          }
        }
        this.update();
        if (callback) {
          if (adapter.invokeSetStateCallback) {
            adapter.invokeSetStateCallback(instance, callback);
          } else {
            callback.call(instance);
          }
        }
      });
    });
    return this;
  }
  setContext(context) {
    if (this[ROOT] !== this) {
      throw new Error('ShallowWrapper::setContext() can only be called on the root');
    }
    if (!this[OPTIONS].context) {
      throw new Error('ShallowWrapper::setContext() can only be called on a wrapper that was originally passed a context option');
    }
    return this.rerender(null, context);
  }
  contains(nodeOrNodes) {
    const adapter = getAdapter(this[OPTIONS]);
    if (!isReactElementAlike(nodeOrNodes, adapter)) {
      throw new Error('ShallowWrapper::contains() can only be called with ReactElement (or array of them), string or number as argument.');
    }
    const predicate = Array.isArray(nodeOrNodes)
      ? other => containsChildrenSubArray(
        nodeEqual,
        other,
        nodeOrNodes.map(node => adapter.elementToNode(node)),
      )
      : other => nodeEqual(adapter.elementToNode(nodeOrNodes), other);
    return findWhereUnwrapped(this, predicate).length > 0;
  }
  containsMatchingElement(node) {
    const adapter = getAdapter(this[OPTIONS]);
    const rstNode = adapter.elementToNode(node);
    const predicate = other => nodeMatches(rstNode, other, (a, b) => a <= b);
    return findWhereUnwrapped(this, predicate).length > 0;
  }
  containsAllMatchingElements(nodes) {
    if (!Array.isArray(nodes)) {
      throw new TypeError('nodes should be an Array');
    }
    return nodes.every(node => this.containsMatchingElement(node));
  }
  containsAnyMatchingElements(nodes) {
    return Array.isArray(nodes) && nodes.some(node => this.containsMatchingElement(node));
  }
  equals(node) {
    return this.single('equals', () => nodeEqual(this.getNodeInternal(), node));
  }
  matchesElement(node) {
    return this.single('matchesElement', () => {
      const adapter = getAdapter(this[OPTIONS]);
      const rstNode = adapter.elementToNode(node);
      return nodeMatches(rstNode, this.getNodeInternal(), (a, b) => a <= b);
    });
  }
  find(selector) {
    return this.wrap(reduceTreesBySelector(selector, this.getNodesInternal()));
  }
  is(selector) {
    const predicate = buildPredicate(selector);
    return this.single('is', n => predicate(n));
  }
  isEmptyRender() {
    return this.type() === null;
  }
  filterWhere(predicate) {
    return filterWhereUnwrapped(this, n => predicate(this.wrap(n)));
  }
  filter(selector) {
    const predicate = buildPredicate(selector);
    return filterWhereUnwrapped(this, predicate);
  }
  not(selector) {
    const predicate = buildPredicate(selector);
    return filterWhereUnwrapped(this, n => !predicate(n));
  }
  text() {
    return this.single('text', getTextFromNode);
  }
  html() {
    return this.single('html', (n) => {
      if (this.type() === null) return null;
      const adapter = getAdapter(this[OPTIONS]);
      const renderer = adapter.createRenderer({ ...this[OPTIONS], mode: 'string' });
      return renderer.render(adapter.nodeToElement(n));
    });
  }
  render() {
    return this.type() === null ? cheerio() : cheerio.load('')(this.html());
  }
  simulate(event, ...args) {
    return this.single('simulate', (n) => {
      this[RENDERER].simulateEvent(n, event, ...args);
      this[ROOT].update();
      return this;
    });
  }
  simulateError(error) {
    return this.single('simulateError', (thisNode) => {
      if (thisNode.nodeType === 'host') {
        throw new TypeError('ShallowWrapper::simulateError() can only be called on custom components');
      }
      const renderer = this[RENDERER];
      if (typeof renderer.simulateError !== 'function') {
        throw new TypeError('your adapter does not support `simulateError`. Try upgrading it!');
      }
      const rootNode = getRootNodeInternal(this);
      const nodeHierarchy = [thisNode].concat(nodeParents(this, thisNode));
      renderer.simulateError(nodeHierarchy, rootNode, error);
      return this;
    });
  }
  props() {
    return this.single('props', propsOfNode);
  }
  state(name) {
    if (this[ROOT] !== this) {
      throw new Error('ShallowWrapper::state() can only be called on the root');
    }
    if (this.instance() === null || this[RENDERER].getNode().nodeType !== 'class') {
      throw new Error('ShallowWrapper::state() can only be called on class components');
    }
    const _state = this.single('state', () => this.instance().state);
    if (typeof name !== 'undefined') {
      if (_state == null) {
        throw new TypeError(`ShallowWrapper::state("${name}") requires that \`state\` not be \`null\` or \`undefined\``);
      }
      return _state[name];
    }
    return _state;
  }
  context(name) {
    if (this[ROOT] !== this) {
      throw new Error('ShallowWrapper::context() can only be called on the root');
    }
    if (!this[OPTIONS].context) {
      throw new Error('ShallowWrapper::context() can only be called on a wrapper that was originally passed a context option');
    }
    if (this.instance() === null) {
      throw new Error('ShallowWrapper::context() can only be called on wrapped nodes that have a non-null instance');
    }
    const _context = this.single('context', () => this.instance().context);
    if (name) {
      return _context[name];
    }
    return _context;
  }
  children(selector) {
    const allChildren = this.flatMap(n => childrenOfNode(n.getNodeInternal()));
    return selector ? allChildren.filter(selector) : allChildren;
  }
  childAt(index) {
    return this.single('childAt', () => this.children().at(index));
  }
  parents(selector) {
    return this.single('parents', (n) => {
      const allParents = this.wrap(nodeParents(this, n));
      return selector ? allParents.filter(selector) : allParents;
    });
  }
  parent() {
    return this.flatMap(n => [n.parents().get(0)]);
  }
  closest(selector) {
    if (this.is(selector)) {
      return this;
    }
    const matchingAncestors = this.parents().filter(selector);
    return matchingAncestors.length > 0 ? matchingAncestors.first() : this.findWhere(() => false);
  }
  shallow(options) {
    return this.single('shallow', n => (
      this.wrap(getAdapter(this[OPTIONS]).nodeToElement(n), null, options)
    ));
  }
  prop(propName) {
    return this.props()[propName];
  }
  key() {
    return this.single('key', n => (n.key === undefined ? null : n.key));
  }
  type() {
    return this.single('type', n => typeOfNode(n));
  }
  name() {
    const adapter = getAdapter(this[OPTIONS]);
    return this.single('name', n => (
      adapter.displayNameOfNode ? adapter.displayNameOfNode(n) : displayNameOfNode(n)
    ));
  }
  hasClass(className) {
    if (className && className.indexOf('.') !== -1) {
      console.warn('It looks like you\'re calling `ShallowWrapper::hasClass()` with a CSS selector. hasClass() expects a class name, not a CSS selector.');
    }
    return this.single('hasClass', n => hasClassName(n, className));
  }
  forEach(fn) {
    this.getNodesInternal().forEach((n, i) => fn.call(this, this.wrap(n), i));
    return this;
  }
  map(fn) {
    return this.getNodesInternal().map((n, i) => fn.call(this, this.wrap(n), i));
  }
  reduce(fn, initialValue = undefined) {
    if (arguments.length > 1) {
      return this.getNodesInternal().reduce(
        (accum, n, i) => fn.call(this, accum, this.wrap(n), i),
        initialValue,
      );
    }
    return this.getNodesInternal().reduce((accum, n, i) => fn.call(
      this,
      i === 1 ? this.wrap(accum) : accum,
      this.wrap(n),
      i,
    ));
  }
  reduceRight(fn, initialValue = undefined) {
    if (arguments.length > 1) {
      return this.getNodesInternal().reduceRight(
        (accum, n, i) => fn.call(this, accum, this.wrap(n), i),
        initialValue,
      );
    }
    return this.getNodesInternal().reduceRight((accum, n, i) => fn.call(
      this,
      i === 1 ? this.wrap(accum) : accum,
      this.wrap(n),
      i,
    ));
  }
  slice(begin, end) {
    return this.wrap(this.getNodesInternal().slice(begin, end));
  }
  some(selector) {
    if (this[ROOT] === this) {
      throw new Error('ShallowWrapper::some() can not be called on the root');
    }
    const predicate = buildPredicate(selector);
    return this.getNodesInternal().some(predicate);
  }
  someWhere(predicate) {
    return this.getNodesInternal().some((n, i) => predicate.call(this, this.wrap(n), i));
  }
  every(selector) {
    const predicate = buildPredicate(selector);
    return this.getNodesInternal().every(predicate);
  }
  everyWhere(predicate) {
    return this.getNodesInternal().every((n, i) => predicate.call(this, this.wrap(n), i));
  }
  flatMap(fn) {
    const nodes = this.getNodesInternal().map((n, i) => fn.call(this, this.wrap(n), i));
    const flattened = flat(nodes, 1);
    return this.wrap(flattened.filter(Boolean));
  }
  findWhere(predicate) {
    return findWhereUnwrapped(this, n => predicate(this.wrap(n)));
  }
  get(index) {
    return this.getElements()[index];
  }
  at(index) {
    const nodes = this.getNodesInternal();
    if (index < nodes.length) {
      return this.wrap(nodes[index]);
    }
    return this.wrap([]);
  }
  first() {
    return this.at(0);
  }
  last() {
    return this.at(this.length - 1);
  }
  isEmpty() {
    console.warn('Enzyme::Deprecated method isEmpty() called, use exists() instead.');
    return !this.exists();
  }
  exists(selector = null) {
    if (arguments.length > 0 && typeof selector !== 'string') {
      throw new TypeError('`selector` argument must be a string, if present.');
    }
    return typeof selector === 'string' ? this.find(selector).exists() : this.length > 0;
  }
  single(name, fn) {
    const fnName = typeof name === 'string' ? name : 'unknown';
    const callback = typeof fn === 'function' ? fn : name;
    if (this.length !== 1) {
      throw new Error(`Method “${fnName}” is only meant to be run on a single node. ${this.length} found instead.`);
    }
    return callback.call(this, this.getNodeInternal());
  }
  wrap(node, root = this[ROOT], ...args) {
    if (node instanceof ShallowWrapper) {
      return node;
    }
    return new ShallowWrapper(node, root, ...args);
  }
  debug(options = {}) {
    return debugNodes(this.getNodesInternal(), options);
  }
  tap(intercepter) {
    intercepter(this);
    return this;
  }
  dive(options = {}) {
    const adapter = getAdapter(this[OPTIONS]);
    const name = 'dive';
    return this.single(name, (n) => {
      if (n && n.nodeType === 'host') {
        throw new TypeError(`ShallowWrapper::${name}() can not be called on Host Components`);
      }
      const el = getAdapter(this[OPTIONS]).nodeToElement(n);
      if (!isCustomComponentElement(el, adapter)) {
        throw new TypeError(`ShallowWrapper::${name}() can only be called on components`);
      }
      return this.wrap(el, null, { ...this[OPTIONS], ...options });
    });
  }
  hostNodes() {
    return this.filterWhere(n => typeof n.type() === 'string');
  }
}
if (ITERATOR_SYMBOL) {
  Object.defineProperty(ShallowWrapper.prototype, ITERATOR_SYMBOL, {
    configurable: true,
    value: function iterator() {
      const iter = this.getNodesInternal()[ITERATOR_SYMBOL]();
      const adapter = getAdapter(this[OPTIONS]);
      return {
        [ITERATOR_SYMBOL]() { return this; },
        next() {
          const next = iter.next();
          if (next.done) {
            return { done: true };
          }
          return {
            done: false,
            value: adapter.nodeToElement(next.value),
          };
        },
      };
    },
  });
}
function privateWarning(prop, extraMessage) {
  Object.defineProperty(ShallowWrapper.prototype, prop, {
    get() {
      throw new Error(`
        Attempted to access ShallowWrapper::${prop}, which was previously a private property on
        Enzyme ShallowWrapper instances, but is no longer and should not be relied upon.
        ${extraMessage}
      `);
    },
    enumerable: false,
    configurable: false,
  });
}
privateWarning('node', 'Consider using the getElement() method instead.');
privateWarning('nodes', 'Consider using the getElements() method instead.');
privateWarning('renderer', '');
privateWarning('options', '');
privateWarning('complexSelector', '');
export default ShallowWrapper;
