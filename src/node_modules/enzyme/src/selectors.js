import { createParser } from 'rst-selector-parser';
import values from 'object.values';
import flat from 'array.prototype.flat';
import is from 'object-is';
import has from 'has';
import {
  treeFilter,
  nodeHasId,
  findParentNode,
  nodeMatchesObjectProps,
  childrenOfNode,
  hasClassName,
} from './RSTTraversal';
import { nodeHasType, propsOfNode } from './Utils';
import getAdapter from './getAdapter';
const parser = createParser();
const CHILD = 'childCombinator';
const ADJACENT_SIBLING = 'adjacentSiblingCombinator';
const GENERAL_SIBLING = 'generalSiblingCombinator';
const DESCENDANT = 'descendantCombinator';
const SELECTOR = 'selector';
const TYPE_SELECTOR = 'typeSelector';
const CLASS_SELECTOR = 'classSelector';
const ID_SELECTOR = 'idSelector';
const ATTRIBUTE_PRESENCE = 'attributePresenceSelector';
const ATTRIBUTE_VALUE = 'attributeValueSelector';
const PSEUDO_CLASS = 'pseudoClassSelector';
const PSEUDO_ELEMENT = 'pseudoElementSelector';
const EXACT_ATTRIBUTE_OPERATOR = '=';
const WHITELIST_ATTRIBUTE_OPERATOR = '~=';
const HYPHENATED_ATTRIBUTE_OPERATOR = '|=';
const PREFIX_ATTRIBUTE_OPERATOR = '^=';
const SUFFIX_ATTRIBUTE_OPERATOR = '$=';
const SUBSTRING_ATTRIBUTE_OPERATOR = '*=';
function unique(arr) {
  return [...new Set(arr)];
}
function uniqueReduce(fn, nodes) {
  return unique(nodes.reduce(fn, []));
}
function safelyGenerateTokens(selector) {
  try {
    return parser.parse(selector);
  } catch (err) {
    throw new Error(`Failed to parse selector: ${selector}`);
  }
}
function matchAttributeSelector(node, token) {
  const { operator, value, name } = token;
  const nodeProps = propsOfNode(node);
  const descriptor = Object.getOwnPropertyDescriptor(nodeProps, name);
  if (descriptor && descriptor.get) {
    return false;
  }
  const nodePropValue = nodeProps[name];
  if (typeof nodePropValue === 'undefined') {
    return false;
  }
  if (token.type === ATTRIBUTE_PRESENCE) {
    return has(nodeProps, token.name);
  }
  if (typeof nodePropValue !== 'string' || typeof value !== 'string') {
    if (operator !== EXACT_ATTRIBUTE_OPERATOR) {
      return false;
    }
  }
  switch (operator) {
    case EXACT_ATTRIBUTE_OPERATOR:
      return is(nodePropValue, value);
    case WHITELIST_ATTRIBUTE_OPERATOR:
      return nodePropValue.split(' ').indexOf(value) !== -1;
    case HYPHENATED_ATTRIBUTE_OPERATOR:
      return nodePropValue === value || nodePropValue.startsWith(`${value}-`);
    case PREFIX_ATTRIBUTE_OPERATOR:
      return value === '' ? false : nodePropValue.slice(0, value.length) === value;
    case SUFFIX_ATTRIBUTE_OPERATOR:
      return value === '' ? false : nodePropValue.slice(-value.length) === value;
    case SUBSTRING_ATTRIBUTE_OPERATOR:
      return value === '' ? false : nodePropValue.indexOf(value) !== -1;
    default:
      throw new Error(`Enzyme::Selector: Unknown attribute selector operator "${operator}"`);
  }
}
function matchPseudoSelector(node, token, root) {
  const { name, parameters } = token;
  if (name === 'not') {
    return parameters.every(selector => reduceTreeBySelector(selector, node).length === 0);
  }
  if (name === 'empty') {
    return treeFilter(node, n => n !== node).length === 0;
  }
  if (name === 'first-child') {
    const { rendered } = findParentNode(root, node);
    const [firstChild] = rendered;
    return firstChild === node;
  }
  if (name === 'last-child') {
    const { rendered } = findParentNode(root, node);
    return rendered[rendered.length - 1] === node;
  }
  throw new TypeError(`Enzyme::Selector does not support the "${token.name}" pseudo-element or pseudo-class selectors.`);
}
function nodeMatchesToken(node, token, root) {
  if (node === null || typeof node === 'string') {
    return false;
  }
  switch (token.type) {
    case CLASS_SELECTOR:
      return hasClassName(node, token.name);
    case TYPE_SELECTOR:
      return nodeHasType(node, token.name);
    case ID_SELECTOR:
      return nodeHasId(node, token.name);
    case ATTRIBUTE_PRESENCE:
      return matchAttributeSelector(node, token);
    case ATTRIBUTE_VALUE:
      return matchAttributeSelector(node, token);
    case PSEUDO_ELEMENT:
    case PSEUDO_CLASS:
      return matchPseudoSelector(node, token, root);
    default:
      throw new Error(`Unknown token type: ${token.type}`);
  }
}
function buildPredicateFromToken(token, root) {
  return node => token.body.every(bodyToken => nodeMatchesToken(node, bodyToken, root));
}
function isComplexSelector(tokens) {
  return tokens.some(token => token.type !== SELECTOR);
}
export function buildPredicate(selector) {
  if (typeof selector === 'string') {
    const tokens = safelyGenerateTokens(selector);
    if (isComplexSelector(tokens)) {
      throw new TypeError('This method does not support complex CSS selectors');
    }
    return buildPredicateFromToken(tokens[0]);
  }
  const adapter = getAdapter();
  const isElementType = adapter.isValidElementType
    ? adapter.isValidElementType(selector)
    : typeof selector === 'function';
  if (isElementType) {
    return node => node && node.type === selector;
  }
  if (typeof selector === 'object') {
    if (!Array.isArray(selector) && selector !== null && Object.keys(selector).length > 0) {
      const hasUndefinedValues = values(selector).some(value => typeof value === 'undefined');
      if (hasUndefinedValues) {
        throw new TypeError('Enzyme::Props can’t have `undefined` values. Try using ‘findWhere()’ instead.');
      }
      return node => nodeMatchesObjectProps(node, selector);
    }
    throw new TypeError('Enzyme::Selector does not support an array, null, or empty object as a selector');
  }
  throw new TypeError('Enzyme::Selector expects a string, object, or valid element type (Component Constructor)');
}
function matchAdjacentSiblings(nodes, predicate, root) {
  return nodes.reduce((matches, node) => {
    const parent = findParentNode(root, node);
    if (!parent) {
      return matches;
    }
    const parentChildren = childrenOfNode(parent);
    const nodeIndex = parentChildren.indexOf(node);
    const adjacentSibling = parentChildren[nodeIndex + 1];
    if (!adjacentSibling) {
      return matches;
    }
    if (predicate(adjacentSibling)) {
      matches.push(adjacentSibling);
    }
    return matches;
  }, []);
}
function matchGeneralSibling(nodes, predicate, root) {
  return uniqueReduce((matches, node) => {
    const parent = findParentNode(root, node);
    if (!parent) {
      return matches;
    }
    const parentChildren = childrenOfNode(parent);
    const nodeIndex = parentChildren.indexOf(node);
    const youngerSiblings = parentChildren.slice(nodeIndex + 1);
    return matches.concat(youngerSiblings.filter(predicate));
  }, nodes);
}
function matchDirectChild(nodes, predicate) {
  return uniqueReduce(
    (matches, node) => matches.concat(childrenOfNode(node).filter(predicate)),
    nodes,
  );
}
function matchDescendant(nodes, predicate) {
  return uniqueReduce(
    (matches, node) => matches.concat(treeFilter(node, predicate)),
    flat(nodes.map(childrenOfNode)),
  );
}
export function reduceTreeBySelector(selector, root) {
  if (typeof selector === 'function' || typeof selector === 'object') {
    return treeFilter(root, buildPredicate(selector));
  }
  let results = [];
  if (typeof selector === 'string') {
    const tokens = safelyGenerateTokens(selector);
    let index = 0;
    while (index < tokens.length) {
      const token = tokens[index];
      if (token.type === SELECTOR) {
        const predicate = buildPredicateFromToken(token, root);
        results = results.concat(treeFilter(root, predicate));
      } else {
        const { type } = token;
        index += 1;
        const predicate = buildPredicateFromToken(tokens[index], root);
        switch (type) {
          case ADJACENT_SIBLING:
            results = matchAdjacentSiblings(results, predicate, root);
            break;
          case GENERAL_SIBLING:
            results = matchGeneralSibling(results, predicate, root);
            break;
          case CHILD:
            results = matchDirectChild(results, predicate);
            break;
          case DESCENDANT: {
            results = matchDescendant(results, predicate);
            break;
          }
          default:
            throw new Error(`Unknown combinator selector: ${type}`);
        }
      }
      index += 1;
    }
  } else {
    throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');
  }
  return results;
}
export function reduceTreesBySelector(selector, roots) {
  const results = roots.map(n => reduceTreeBySelector(selector, n));
  return unique(flat(results, 1));
}
