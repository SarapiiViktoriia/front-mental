import * as stream from "stream";
import * as events from "events";
declare namespace MarkupData {
    interface Location {
        line: number;
        col: number;
        startOffset: number;
        endOffset: number;
    }
    interface AttributesLocation {
        [attributeName: string]: Location;
    }
    interface StartTagLocation extends Location {
        attrs: AttributesLocation
    }
    interface ElementLocation extends StartTagLocation {
        startTag: StartTagLocation;
        endTag: Location;
    }
}
declare namespace Options {
    export interface ParserOptions {
        locationInfo?: boolean;
        treeAdapter?: AST.TreeAdapter;
    }
    export interface SAXParserOptions {
        locationInfo?: boolean;
    }
    export interface SerializerOptions {
        treeAdapter?: AST.TreeAdapter;
    }
}
declare namespace AST {
    type DocumentMode = 'no-quirks' | 'quirks' | 'limited-quirks';
    namespace Default {
        interface Attribute {
            name: string;
            value: string;
            namespace?: string;
            prefix?: string;
        }
        interface Node {
            nodeName: string;
        }
        interface ParentNode {
            childNodes: Node[];
        }
        export interface DocumentType extends Node {
            nodeName: '#documentType';
            name: string;
            publicId: string;
            systemId: string;
        }
        export interface Document extends ParentNode {
            nodeName: '#document';
            mode: DocumentMode;
        }
        export interface DocumentFragment extends ParentNode {
            nodeName: '#document-fragment';
        }
        export interface Element extends ParentNode {
            nodeName: string;
            tagName: string;
            namespaceURI: string;
            attrs: Attribute[];
            parentNode: ParentNode;
            __location?: MarkupData.ElementLocation;
        }
        export interface CommentNode extends Node {
            nodeName: '#comment';
            data: string;
            parentNode: ParentNode;
            __location?: MarkupData.Location;
        }
        export interface TextNode extends Node {
            nodeName: '#text';
            value: string;
            parentNode: ParentNode;
            __location?: MarkupData.Location;
        }
    }
    namespace HtmlParser2 {
        interface Node {
            type: string;
            nodeType: number;
            parent: ParentNode;
            parentNode: ParentNode;
            prev: Node;
            previousSibling: Node;
            next: Node;
            nextSibling: Node;
        }
        interface ParentNode extends Node {
            children: Node[];
            childNodes: Node[];
            firstChild: Node;
            lastChild: Node;
        }
        export interface DocumentType extends Node {
            type: 'directive';
            name: '!doctype';
            data: string;
            'x-name':string;
            'x-publicId': string;
            'x-systemId': string;
        }
        export interface Document extends ParentNode {
            type: 'root';
            name: 'root';
            'x-mode': DocumentMode;
        }
        export interface DocumentFragment extends ParentNode {
            type: 'root';
            name: 'root';
        }
        export interface Element extends ParentNode {
            name: string;
            tagName: string;
            namespace: string;
            attribs: { [name: string]: string };
            'x-attribsNamespace': { [name: string]: string };
            'x-attribsPrefix': { [name: string]: string };
            __location?: MarkupData.ElementLocation;
        }
        export interface CommentNode extends Node {
            name: 'comment';
            data: string;
            nodeValue: string;
            __location?: MarkupData.Location;
        }
        export interface TextNode extends Node {
            name: 'text';
            data: string;
            nodeValue: string;
            __location?: MarkupData.Location;
        }
    }
    type Node = Default.Node | HtmlParser2.Node | Object;
    type ParentNode = Default.ParentNode | HtmlParser2.ParentNode | Object;
    type DocumentType = Default.DocumentType | HtmlParser2.DocumentType | Object;
    type Document = Default.Document | HtmlParser2.Document | Object;
    type DocumentFragment = Default.DocumentFragment | HtmlParser2.DocumentFragment | Object;
    type Element = Default.Element | HtmlParser2.Element | Object;
    type TextNode = Default.TextNode | HtmlParser2.TextNode | Object;
    type CommentNode = Default.CommentNode | HtmlParser2.CommentNode | Object;
    export interface TreeAdapter {
        createDocument(): AST.Document;
        createDocumentFragment(): AST.DocumentFragment;
        createElement(tagName: string, namespaceURI: string, attrs: AST.Default.Attribute[]): AST.Element;
        createCommentNode(data: string): AST.CommentNode;
        appendChild(parentNode: AST.ParentNode, newNode: AST.Node): void;
        insertBefore(parentNode: AST.ParentNode, newNode: AST.Node, referenceNode: AST.Node): void;
        setTemplateContent(templateElement: AST.Element, contentElement: AST.DocumentFragment): void;
        getTemplateContent(templateElement: AST.Element): AST.DocumentFragment;
        setDocumentType(document: AST.Document, name: string, publicId: string, systemId: string): void;
        setDocumentMode(document: AST.Document, mode: AST.DocumentMode): void;
        getDocumentMode(document: AST.Document): AST.DocumentMode;
        detachNode(node: AST.Node): void;
        insertText(parentNode: AST.ParentNode, text: string): void;
        insertTextBefore(parentNode: AST.ParentNode, text: string, referenceNode: AST.Node): void;
        adoptAttributes(recipient: AST.Element, attrs: AST.Default.Attribute[]): void;
        getFirstChild(node: AST.ParentNode): AST.Node;
        getChildNodes(node: AST.ParentNode): AST.Node[];
        getParentNode(node: AST.Node): AST.ParentNode;
        getAttrList(element: AST.Element): AST.Default.Attribute[];
        getTagName(element: AST.Element): string;
        getNamespaceURI(element: AST.Element): string;
        getTextNodeContent(textNode: AST.TextNode): string;
        getCommentNodeContent(commentNode: AST.CommentNode): string;
        getDocumentTypeNodeName(doctypeNode: AST.DocumentType): string;
        getDocumentTypeNodePublicId(doctypeNode: AST.DocumentType): string;
        getDocumentTypeNodeSystemId(doctypeNode: AST.DocumentType): string;
        isTextNode(node: AST.Node): boolean;
        isCommentNode(node: AST.Node): boolean;
        isDocumentTypeNode(node: AST.Node): boolean;
        isElementNode(node: AST.Node): boolean;
    }
}
export var treeAdapters: {
    default: AST.TreeAdapter,
    htmlparser2: AST.TreeAdapter
};
export function parse(html: string, options?: Options.ParserOptions): AST.Document;
export function parseFragment(fragmentContext: AST.Element, html: string, options?: Options.ParserOptions): AST.DocumentFragment;
export function parseFragment(html: string, options?: Options.ParserOptions): AST.DocumentFragment;
export function serialize(node: AST.Node, options?: Options.SerializerOptions): string;
export class ParserStream extends stream.Writable {
    constructor(options?: Options.ParserOptions);
    document: AST.Document;
    on(event: 'script', listener: (scriptElement: AST.Element, documentWrite: (html: string) => void, resume: () => void) => void): this;
    on(event: string, listener: Function): this;
}
export class PlainTextConversionStream extends ParserStream { }
export class SAXParser extends stream.Transform {
    constructor(options?: Options.SAXParserOptions);
    on(event: 'startTag', listener: (name: string, attrs: AST.Default.Attribute[], selfClosing: boolean, location?: MarkupData.StartTagLocation) => void): this;
    on(event: 'endTag', listener: (name: string, location?: MarkupData.Location) => void): this;
    on(event: 'comment', listener: (text: string, location?: MarkupData.Location) => void): this;
    on(event: 'text', listener: (text: string, location?: MarkupData.Location) => void): this;
    on(event: 'doctype', listener: (name: string, publicId: string, systemId: string, location?: MarkupData.Location) => void): this;
    on(event: string, listener: Function): this;
    stop(): void;
}
export class SerializerStream extends stream.Readable {
    constructor(node: AST.Node, options?: Options.SerializerOptions);
}
